#include <iostream>

/*
Сложность O(logN)
!!Последовательность должна быть упорядочена
Алгоритм поиска границы (левой в данном случае)
числа может и не быть, а гнаница есть
Идея: ИЩЕМ ТО МЕСТО ГДЕ МОГ СТОЯТЬ БЫ ПРОВЕРЯЕМЫЙ ЭЛЕМЕНТ
или должен стоять в этой последовательности

Выбираем крайние индексы последовательности
и если сразу можно сказать по краям то так и делаем.

иначе ищем левый край пока не найдем 2 смежных элемента деля и отбрасывая
половинки, но интервалы сдвигаем до среднего элемента, так как ищем смежную пару
в итоге r - индекс должен покахывать на правый элемнт пары, левый на левый

*/

int LeftBoundary( int arr[], int N, int insertElement )
{
    int l = -1;
    int r = N;

    //    if ( insertElement > arr[ N - 1 ] )
    //        return r;
    //    if ( insertElement < arr[ 0 ] )
    //        return l;

    while ( ( r - l ) > 1 ) {
        int m = ( l + r ) / 2;
        if ( arr[ m ] < insertElement ) {
            l = m;
        } else {
            r = m;
        }
    }

    return l;
}

int main()
{
    int arr[] { 1, 2, 3, 5, 7, 7, 7, 9, 10, 12 };
    std::cout << LeftBoundary( arr, 10, 0 );
}
