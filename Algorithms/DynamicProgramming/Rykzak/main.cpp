#include <iostream>
#include <vector>

void debugPrint( std::vector< std::vector< double > > F ) {
  for ( auto el : F ) {
    for ( auto el1 : el ) std::cout << el1 << "\t";
    std::cout << "\n";
  }
  std::cout << "\n";
  std::cout << "\n";
}

/*
Задача о рюкзаке (англ. Knapsack problem) — дано N предметов, ni предмет имеет
массу wi>0 и стоимость pi>0. Необходимо выбрать из этих предметов такой набор,
чтобы суммарная масса не превосходила заданной величины W (вместимость рюкзака),
а суммарная стоимость была максимальна

https://neerc.ifmo.ru/wiki/index.php?title=%D0%97%D0%B0%D0%B4%D0%B0%D1%87%D0%B0_%D0%BE_%D1%80%D1%8E%D0%BA%D0%B7%D0%B0%D0%BA%D0%B5
Пусть A(k,s) есть максимальная стоимость предметов, которые можно уложить в
рюкзак вместимости s, если можно использовать только первые k предметов, то есть
{n1,n2,…,nk}, назовем этот набор допустимых предметов для A(k,s).

A(k,0)=0
A(0,s)=0
Найдем A(k,s). Возможны 2 варианта:
1: Если предмет k не попал в рюкзак. Тогда A(k,s) равно максимальной стоимости
рюкзака с такой же вместимостью и набором допустимых предметов {n1,n2,…,nk−1},
то есть A(k,s)=A(k−1,s)

2: Если k попал в рюкзак. Тогда A(k,s) равно максимальной стоимости рюкзака,
где вес s уменьшаем на вес k-ого предмета и набор допустимых предметов
{n1,n2,…,nk−1} плюс стоимость k, то есть A(k−1,s−wk)+pk

A(k,s)={A(k−1,s), bk=0
       {A(k−1,s−wk)+pk, bk=1

То есть: A(k,s)=max(A(k−1,s),A(k−1,s−wk)+pk)
Стоимость искомого набора равна A(N,W), так как нужно найти максимальную
стоимость рюкзака, где все предметы допустимы и вместимость рюкзака W.
Восстановим набор предметов, входящих в рюкзак
Будем определять, входит ли ni предмет в искомый набор. Начинаем с элемента
A(i,w), где i=N, w=W. Для этого сравниваем A(i,w) со следующими значениями:
Максимальная стоимость рюкзака с такой же вместимостью и набором допустимых
предметов {n1,n2,…,ni−1}, то есть A(i−1,w) Максимальная стоимость рюкзака с
вместимостью на wi меньше и набором допустимых предметов {n1,n2,…,ni−1} плюс
стоимость pi, то есть A(i−1,w−wi)+pi Заметим, что при построении A мы выбирали
максимум из этих значений и записывали в A(i,w). Тогда будем сравнивать A(i,w) c
A(i−1,w), если равны, тогда ni не входит в искомый набор, иначе входит.



https://www.youtube.com/watch?v=4E-_uzO0A_A&t=11361s
2:10:30
Динамическое решение
еще описание Седжевик стр.205
*/

/*
Методом восходящего динамического программирования
сложность O(M*N)
*/
double maxBackpackValue( std::vector< std::pair< int, double > > treasures,
                         int capacityRykzaka ) {
  // 1. Подготовка матрицы ответов
  std::vector< std::vector< double > > F(
      capacityRykzaka + 1, std::vector< double >( treasures.size( ) + 1 ) );

  // 2.
  //Базовые случаи:
  // a: - вес в рюкзаках при 0 предметов = 0
  for ( int i = 0; i <= capacityRykzaka; ++i ) {
    F[ i ][ 0 ] = 0;
  }
  // b: - при нулевой вместимости рюкзака можно положить 0 предметов
  for ( std::size_t j = 0; j <= treasures.size( ); ++j ) {
    F[ 0 ][ j ] = 0;
  }

  debugPrint( F );

  // 3.Вычисление
  // Рекурретная формула:
  // Функция F от ( вместимости мешка и ценности предметов в нем ) (F(i, j))
  // = максимуму из вариантов(возможностей) 1: при !!! НЕ !!! выборе текущей
  // стоимости вещи j (нет места под нее), тогда F(i, j - 1) и 2: вещь j
  // выбираетсz - ценности текущего предмета + максимальная ценность
  // предметов в мешке без него, и раз предмет выбираем то вместимость мешка
  // надо уменьшить на вес выбранного предмета

  // F(i, j) = max( F(i, j - 1), ценность j + F(i - вес i, j - 1) );

  for ( std::size_t j = 1; j <= treasures.size( ); ++j ) {
    int weightCurrent = treasures[ j - 1 ].first;
    double cennostCurrent = treasures[ j - 1 ].second;
    //пока предмет не может быть взят, просто копируем ценности предыдущих
    //вычислений
    for ( int k = 1; k <= weightCurrent; ++k ) {
      F[ k ][ j ] = F[ k ][ j - 1 ];
    }

    // debugPrint( F );

    for ( int k = weightCurrent; k <= capacityRykzaka; ++k ) {
      F[ k ][ j ] = std::max(
          F[ k ][ j - 1 ], cennostCurrent + F[ k - weightCurrent ][ j - 1 ] );
    }

    debugPrint( F );
  }
  return F[ capacityRykzaka ][ treasures.size( ) ];
}

int main( ) {
  // first - вес
  // second - ценность
  std::vector< std::pair< int, double > > treasures {
      { 2, 3 }, { 3, 1 }, { 5, 6 }, { 1, 2 } };
  std::cout << maxBackpackValue( treasures, 5 );
}
