#ifndef CONNECTEDNESSTREE_H
#define CONNECTEDNESSTREE_H
#include <memory>

/*
Алгоритм выполняется за O(M*N / 2) квадратичная сложность
МЕТОД БЫСТРОГО ОБЬЕДИНЕНИЯ
структура данных - массив
интерпретация - каждый обьект указывает на бругой обьект в связанном уже множестве
что приводит к структуре дерево - построенному на массиве
обьекты связаны тогда и только тогда, когда следование по указателям
приводит к одному обьекту - корню, тогда эти элементы
принадлежат одному дереву - связаны

ПРОБЛЕМА: при последовательном связывании 1-2, 2-3, 3-4 и тд.
получим дерево из одной линии, тем самым получим ситуацию когда при М
вволимых парах, надо пройти по 1,2,3....N-1 указателям.
тогда среднее значение N(N-1)/2N = (N-1)/2
Если же, вводимые пары уже имеют связь, то при их проверке
надо пройти для каждой до корня дерева, тогда поиск для таких пар > чем MN/2
*/

class ConnectednessTree
{
public:
    explicit ConnectednessTree( int count_elements );
    void Display( ) const;
    void Read( );

    void Connectedness( int index_p, int index_q );

private:
    std::unique_ptr< int[], void ( * )( int * ) > array_;
    int count_element_;
};

#endif // CONNECTEDNESSTREE_H
