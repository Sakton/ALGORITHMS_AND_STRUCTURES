#include <cstdint>
#include <iostream>

/*
 *
Сложность O() ????
Алгоритмы и структуры данных (С++), лекция №10
Метод ветвей и границ
Базовый случай: номер совпадает с текущим числом в рамках множества
[перестановочное множество] это означает что перестановка сгенерирована и ее
можно напечатать

Рекуррентный случай:
в цикле от наименьшего числа до макс - 1 формировать перестановки.

Массив буфер нужен для хранения перестановки
Массив used для индикации уже использованного числа, чтобы отсечь ненужные ветви
где есть поторения

статические и глобальные переменные лучше не использовать ввиду многопоточности


цикл запускает нужные ветви, которые начинаются с разных чисел участвующих в
перестановке затем по следующей позиции чисел и тд.
0XX, 1XX, 2XX ->
(00X, 01X, 02X), (10X, 11X, 12X), (20X, 21X, 22X)
(000, 001, 002), (010, 011, 012), (020, 021, 022) и так далее по остальным

*/

void Permutations( int16_t number, int16_t current, int16_t buffer[],
                   bool used[] ) {
  if ( number == current ) {
    for ( int i = 0; i < number; ++i ) std::cout << buffer[ i ] << " ";
    std::cout << std::endl;
  } else {
    for ( int16_t i = 0; i < number; ++i ) {
      if ( !used[ i ] ) {
        used[ i ] = true;
        buffer[ current ] = i;
        Permutations( number, current + 1, buffer, used );
        used[ i ] = false;
      }
    }
  }
}

int main( ) {
  int16_t buffer[ 10 ] { 0 };
  bool used[ 10 ] { false };
  Permutations( 4, 0, buffer, used );
}
